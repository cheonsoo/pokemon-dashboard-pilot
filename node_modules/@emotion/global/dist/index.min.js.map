{"version":3,"file":"index.min.js","sources":["../../sheet/src/index.js","../../utils/src/index.js","../../unitless/src/index.js","../../memoize/src/index.js","../../serialize/src/index.js","../../hash/src/index.js","../src/index.js","../../../rollupPluginBabelHelpers"],"sourcesContent":["// @flow\n/*\n\nhigh performance StyleSheet for css-in-js systems\n\n- uses multiple style tags behind the scenes for millions of rules\n- uses `insertRule` for appending in production for *much* faster performance\n- 'polyfills' on server side\n\n// usage\n\nimport StyleSheet from 'glamor/lib/sheet'\nlet styleSheet = new StyleSheet()\n\nstyleSheet.inject()\n- 'injects' the stylesheet into the page (or into memory if on server)\n\nstyleSheet.insert('#box { border: 1px solid red; }')\n- appends a css rule into the stylesheet\n\nstyleSheet.flush()\n- empties the stylesheet of all its contents\n\n*/\n\n// $FlowFixMe\nfunction sheetForTag(tag: HTMLStyleElement): CSSStyleSheet {\n  if (tag.sheet) {\n    // $FlowFixMe\n    return tag.sheet\n  }\n\n  // this weirdness brought to you by firefox\n  /* istanbul ignore next */\n  for (let i = 0; i < document.styleSheets.length; i++) {\n    if (document.styleSheets[i].ownerNode === tag) {\n      // $FlowFixMe\n      return document.styleSheets[i]\n    }\n  }\n}\n\nexport type Options = {\n  nonce?: string,\n  key?: string,\n  container?: HTMLElement,\n  speedy?: boolean,\n  maxLength?: number\n}\n\nexport class StyleSheet {\n  isSpeedy: boolean\n  ctr: number\n  tags: HTMLStyleElement[]\n  container: HTMLElement\n  maxLength: number\n  key: string | void\n  nonce: string | void\n  constructor(options: Options | void) {\n    if (options === undefined) options = {}\n    this.isSpeedy =\n      options.speedy === undefined\n        ? process.env.NODE_ENV === 'production'\n        : options.speedy\n    // maxLength is how many rules we have per style tag, it's 65000 in speedy mode\n    // because that's the upper limit in IE 10 TODO: make sure that is actually correct\n    // it's 1 in dev because we insert source maps that map a single rule to a location\n    // and you can only have one source map per style tag\n    this.maxLength = options.maxLength || this.isSpeedy ? 65000 : 1\n    this.tags = []\n    this.ctr = 0\n    this.nonce = options.nonce\n    // key is the value of the data-emotion attribute, it's used to identify different sheets\n    this.key = options.key || ''\n    // $FlowFixMe\n    this.container =\n      options.container ||\n      (typeof document !== 'undefined' ? document.head : null)\n  }\n  insert(rule: string) {\n    if (this.ctr % this.maxLength === 0) {\n      let tag = document.createElement('style')\n      tag.setAttribute('data-emotion', this.key)\n      if (this.nonce !== undefined) {\n        tag.setAttribute('nonce', this.nonce)\n      }\n      tag.appendChild(document.createTextNode(''))\n      this.container.appendChild(tag)\n      this.tags.push(tag)\n    }\n    const tag = this.tags[this.tags.length - 1]\n\n    if (this.isSpeedy) {\n      const sheet = sheetForTag(tag)\n      try {\n        // this is the ultrafast version, works across browsers\n        // the big drawback is that the css won't be editable in devtools\n        sheet.insertRule(rule, sheet.cssRules.length)\n      } catch (e) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\n            `There was a problem inserting the following rule: \"${rule}\"`,\n            e\n          )\n        }\n      }\n    } else {\n      tag.appendChild(document.createTextNode(rule))\n    }\n    this.ctr++\n  }\n  flush() {\n    // $FlowFixMe\n    this.tags.forEach(tag => tag.parentNode.removeChild(tag))\n    this.tags = []\n    this.ctr = 0\n  }\n}\n","// @flow\nimport type { CSSCache, CSSContextType, InsertableStyles } from '@emotion/types'\n\nexport const isBrowser = typeof document !== 'undefined'\nexport const shouldSerializeToReactTree =\n  !isBrowser || process.env.NODE_ENV === 'test'\n\nexport function getRegisteredStyles(\n  registered: CSSCache,\n  registeredStyles: string[],\n  classNames: string\n) {\n  let rawClassName = ''\n\n  classNames.split(' ').forEach(className => {\n    if (registered[className] !== undefined) {\n      registeredStyles.push(registered[className])\n    } else {\n      rawClassName += `${className} `\n    }\n  })\n  return rawClassName\n}\n\nexport const insertStyles = (\n  context: CSSContextType,\n  insertable: InsertableStyles\n) => {\n  if (\n    insertable.type === 1 &&\n    context.registered[`css-${insertable.name}`] === undefined\n  ) {\n    context.registered[`css-${insertable.name}`] = insertable.styles\n  }\n  if (context.inserted[insertable.name] === undefined) {\n    let rules = context.stylis(\n      insertable.type === 1 ? `.css-${insertable.name}` : '',\n      insertable.styles\n    )\n\n    if (shouldSerializeToReactTree) {\n      context.inserted[insertable.name] = rules.join('')\n    } else {\n      rules.forEach(rule => {\n        context.sheet.insert(rule)\n      })\n      context.inserted[insertable.name] = true\n    }\n    if (context.compat === undefined) {\n      return context.inserted[insertable.name]\n    }\n  }\n}\n","// @flow\nexport default {\n  animationIterationCount: 1,\n  borderImageOutset: 1,\n  borderImageSlice: 1,\n  borderImageWidth: 1,\n  boxFlex: 1,\n  boxFlexGroup: 1,\n  boxOrdinalGroup: 1,\n  columnCount: 1,\n  columns: 1,\n  flex: 1,\n  flexGrow: 1,\n  flexPositive: 1,\n  flexShrink: 1,\n  flexNegative: 1,\n  flexOrder: 1,\n  gridRow: 1,\n  gridRowEnd: 1,\n  gridRowSpan: 1,\n  gridRowStart: 1,\n  gridColumn: 1,\n  gridColumnEnd: 1,\n  gridColumnSpan: 1,\n  gridColumnStart: 1,\n  fontWeight: 1,\n  lineHeight: 1,\n  opacity: 1,\n  order: 1,\n  orphans: 1,\n  tabSize: 1,\n  widows: 1,\n  zIndex: 1,\n  zoom: 1,\n  WebkitLineClamp: 1,\n\n  // SVG-related properties\n  fillOpacity: 1,\n  floodOpacity: 1,\n  stopOpacity: 1,\n  strokeDasharray: 1,\n  strokeDashoffset: 1,\n  strokeMiterlimit: 1,\n  strokeOpacity: 1,\n  strokeWidth: 1\n}\n","// @flow\n\nexport default function memoize(fn: string => any) {\n  const cache = {}\n\n  return (arg: string) => {\n    if (cache[arg] === undefined) cache[arg] = fn(arg)\n    return cache[arg]\n  }\n}\n","// @flow\nimport type {\n  Interpolation,\n  ScopedInsertableStyles,\n  CSSCache\n} from '@emotion/types'\nimport hashString from '@emotion/hash'\nimport unitless from '@emotion/unitless'\nimport memoize from '@emotion/memoize'\n\nconst hyphenateRegex = /[A-Z]|^ms/g\n\nexport const processStyleName: (styleName: string) => string = memoize(\n  (styleName: string) => styleName.replace(hyphenateRegex, '-$&').toLowerCase()\n)\n\nexport let processStyleValue = (key: string, value: string): string => {\n  if (value == null || typeof value === 'boolean') {\n    return ''\n  }\n\n  if (\n    unitless[key] !== 1 &&\n    key.charCodeAt(1) !== 45 && // custom properties\n    !isNaN(value) &&\n    value !== 0\n  ) {\n    return value + 'px'\n  }\n  return value\n}\n\nif (process.env.NODE_ENV !== 'production') {\n  let contentValuePattern = /(attr|calc|counters?|url)\\(/\n  let contentValues = [\n    'normal',\n    'none',\n    'counter',\n    'open-quote',\n    'close-quote',\n    'no-open-quote',\n    'no-close-quote',\n    'initial',\n    'inherit',\n    'unset'\n  ]\n  let oldProcessStyleValue = processStyleValue\n  processStyleValue = (key: string, value: string) => {\n    if (key === 'content') {\n      if (\n        typeof value !== 'string' ||\n        (contentValues.indexOf(value) === -1 &&\n          !contentValuePattern.test(value) &&\n          (value.charAt(0) !== value.charAt(value.length - 1) ||\n            (value.charAt(0) !== '\"' && value.charAt(0) !== \"'\")))\n      ) {\n        console.error(\n          `You seem to be using a value for 'content' without quotes, try replacing it with \\`content: '\"${value}\"'\\``\n        )\n      }\n    }\n    return oldProcessStyleValue(key, value)\n  }\n}\n\nexport function handleInterpolation(\n  registered: CSSCache,\n  interpolation: Interpolation\n): string | number {\n  if (interpolation == null) {\n    return ''\n  }\n\n  switch (typeof interpolation) {\n    case 'boolean':\n      return ''\n    case 'function':\n      if (this === undefined) {\n        return interpolation.toString()\n      }\n      return handleInterpolation.call(\n        this,\n        registered,\n        // $FlowFixMe\n        interpolation(this)\n      )\n    case 'object':\n      if (interpolation.type === 2) {\n        return interpolation.name\n      }\n      if (interpolation.styles !== undefined) {\n        return interpolation.styles\n      }\n\n      return createStringFromObject.call(this, registered, interpolation)\n    default:\n      const cached = registered[interpolation]\n      return cached !== undefined ? cached : interpolation\n  }\n}\n\nfunction createStringFromObject(\n  registered: CSSCache,\n  obj: { [key: string]: Interpolation }\n): string {\n  let string = ''\n\n  if (Array.isArray(obj)) {\n    obj.forEach(function(interpolation: Interpolation) {\n      string += handleInterpolation.call(this, registered, interpolation)\n    }, this)\n  } else {\n    Object.keys(obj).forEach(function(key: string) {\n      if (typeof obj[key] !== 'object') {\n        string += `${processStyleName(key)}:${processStyleValue(\n          key,\n          obj[key]\n        )};`\n      } else {\n        if (Array.isArray(obj[key]) && typeof obj[key][0] === 'string') {\n          obj[key].forEach(value => {\n            string += `${processStyleName(key)}:${processStyleValue(\n              key,\n              value\n            )};`\n          })\n        } else {\n          string += `${key}{${handleInterpolation.call(\n            this,\n            registered,\n            obj[key]\n          )}}`\n        }\n      }\n    }, this)\n  }\n\n  return string\n}\n\nexport const labelPattern = /label:\\s*([^\\s;\\n{]+)\\s*;/g\n\nexport const serializeStyles = function(\n  registered: CSSCache,\n  args: Array<Interpolation>\n): ScopedInsertableStyles {\n  if (\n    args.length === 1 &&\n    typeof args[0] === 'object' &&\n    args[0] !== null &&\n    args[0].styles !== undefined\n  ) {\n    return args[0]\n  }\n  let styles = ''\n  let identifierName = ''\n  args.forEach(function(interpolation, i) {\n    styles += handleInterpolation.call(this, registered, interpolation)\n  }, this)\n  styles = styles.replace(labelPattern, (match, p1: string) => {\n    identifierName += `-${p1}`\n    return ''\n  })\n  let name = hashString(styles) + identifierName\n\n  return {\n    type: 1,\n    name,\n    styles\n  }\n}\n","// @flow\n/* eslint-disable */\n// murmurhash2 via https://github.com/garycourt/murmurhash-js/blob/master/murmurhash2_gc.js\n\nexport default function murmurhash2_32_gc(str: string) {\n  var l = str.length,\n    h = l ^ l,\n    i = 0,\n    k\n\n  while (l >= 4) {\n    k =\n      (str.charCodeAt(i) & 0xff) |\n      ((str.charCodeAt(++i) & 0xff) << 8) |\n      ((str.charCodeAt(++i) & 0xff) << 16) |\n      ((str.charCodeAt(++i) & 0xff) << 24)\n\n    k = (k & 0xffff) * 0x5bd1e995 + ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16)\n    k ^= k >>> 24\n    k = (k & 0xffff) * 0x5bd1e995 + ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16)\n\n    h =\n      ((h & 0xffff) * 0x5bd1e995 +\n        ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16)) ^\n      k\n\n    l -= 4\n    ++i\n  }\n\n  switch (l) {\n    case 3:\n      h ^= (str.charCodeAt(i + 2) & 0xff) << 16\n    case 2:\n      h ^= (str.charCodeAt(i + 1) & 0xff) << 8\n    case 1:\n      h ^= str.charCodeAt(i) & 0xff\n      h =\n        (h & 0xffff) * 0x5bd1e995 + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16)\n  }\n\n  h ^= h >>> 13\n  h = (h & 0xffff) * 0x5bd1e995 + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16)\n  h ^= h >>> 15\n\n  return (h >>> 0).toString(36)\n}\n","// @flow\nimport * as React from 'react'\nimport { consume } from '@emotion/core'\nimport type { CSSContextType } from '@emotion/types'\nimport { StyleSheet } from '@emotion/sheet'\nimport { isBrowser, shouldSerializeToReactTree } from '@emotion/utils'\nimport { serializeStyles } from '@emotion/serialize'\n\ntype GlobalProps = {\n  css: Object | Array<Object>\n}\n\nclass Global extends React.Component<GlobalProps> {\n  sheet: StyleSheet\n  oldName: string\n  serialized: string\n  static __emotion_component = true\n  renderChild = (context: CSSContextType) => {\n    const serialized = serializeStyles(context.registered, [this.props.css])\n    if (this.oldName !== serialized.name) {\n      if (isBrowser) {\n        this.sheet = new StyleSheet({\n          // $FlowFixMe\n          key: `${context.sheet.key}-global`,\n          // $FlowFixMe\n          nonce: context.sheet.nonce,\n          // $FlowFixMe\n          container: context.sheet.container\n        })\n      }\n      this.oldName = serialized.name\n      let rules = context.stylis(``, serialized.styles)\n      if (shouldSerializeToReactTree) {\n        this.serialized = rules.join('')\n      }\n\n      if (isBrowser) {\n        this.sheet.flush()\n        rules.forEach(rule => {\n          this.sheet.insert(rule)\n        })\n      }\n    }\n    if (shouldSerializeToReactTree) {\n      return (\n        <style\n          data-emotion-ssr={serialized.name}\n          dangerouslySetInnerHTML={{ __html: this.serialized }}\n        />\n      )\n    }\n    return null\n  }\n\n  componentWillUnmount() {\n    this.sheet.flush()\n  }\n  render() {\n    return consume(this.renderChild)\n  }\n}\n\nexport default Global\n","export { _typeof as typeof, _jsx as jsx, _asyncIterator as asyncIterator, _AwaitValue as AwaitValue, _AsyncGenerator as AsyncGenerator, _wrapAsyncGenerator as wrapAsyncGenerator, _awaitAsyncGenerator as awaitAsyncGenerator, _asyncGeneratorDelegate as asyncGeneratorDelegate, _asyncToGenerator as asyncToGenerator, _classCallCheck as classCallCheck, _createClass as createClass, _defineEnumerableProperties as defineEnumerableProperties, _defaults as defaults, _defineProperty as defineProperty, _extends as extends, _get as get, _inherits as inherits, _inheritsLoose as inheritsLoose, _wrapNativeSuper as wrapNativeSuper, _instanceof as instanceof, _interopRequireDefault as interopRequireDefault, _interopRequireWildcard as interopRequireWildcard, _newArrowCheck as newArrowCheck, _objectDestructuringEmpty as objectDestructuringEmpty, _objectWithoutProperties as objectWithoutProperties, _assertThisInitialized as assertThisInitialized, _possibleConstructorReturn as possibleConstructorReturn, _set as set, _slicedToArray as slicedToArray, _slicedToArrayLoose as slicedToArrayLoose, _taggedTemplateLiteral as taggedTemplateLiteral, _taggedTemplateLiteralLoose as taggedTemplateLiteralLoose, _temporalRef as temporalRef, _readOnlyError as readOnlyError, _classNameTDZError as classNameTDZError, _temporalUndefined as temporalUndefined, _toArray as toArray, _toConsumableArray as toConsumableArray, _skipFirstGeneratorNext as skipFirstGeneratorNext, _toPropertyKey as toPropertyKey, _initializerWarningHelper as initializerWarningHelper, _initializerDefineProperty as initializerDefineProperty, _applyDecoratedDescriptor as applyDecoratedDescriptor };\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nvar REACT_ELEMENT_TYPE;\n\nfunction _jsx(type, props, key, children) {\n  if (!REACT_ELEMENT_TYPE) {\n    REACT_ELEMENT_TYPE = typeof Symbol === \"function\" && Symbol.for && Symbol.for(\"react.element\") || 0xeac7;\n  }\n\n  var defaultProps = type && type.defaultProps;\n  var childrenLength = arguments.length - 3;\n\n  if (!props && childrenLength !== 0) {\n    props = {\n      children: void 0\n    };\n  }\n\n  if (props && defaultProps) {\n    for (var propName in defaultProps) {\n      if (props[propName] === void 0) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  } else if (!props) {\n    props = defaultProps || {};\n  }\n\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = new Array(childrenLength);\n\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 3];\n    }\n\n    props.children = childArray;\n  }\n\n  return {\n    $$typeof: REACT_ELEMENT_TYPE,\n    type: type,\n    key: key === undefined ? null : '' + key,\n    ref: null,\n    props: props,\n    _owner: null\n  };\n}\n\nfunction _asyncIterator(iterable) {\n  if (typeof Symbol === \"function\") {\n    if (Symbol.asyncIterator) {\n      var method = iterable[Symbol.asyncIterator];\n      if (method != null) return method.call(iterable);\n    }\n\n    if (Symbol.iterator) {\n      return iterable[Symbol.iterator]();\n    }\n  }\n\n  throw new TypeError(\"Object is not async iterable\");\n}\n\nfunction _AwaitValue(value) {\n  this.wrapped = value;\n}\n\nfunction _AsyncGenerator(gen) {\n  var front, back;\n\n  function send(key, arg) {\n    return new Promise(function (resolve, reject) {\n      var request = {\n        key: key,\n        arg: arg,\n        resolve: resolve,\n        reject: reject,\n        next: null\n      };\n\n      if (back) {\n        back = back.next = request;\n      } else {\n        front = back = request;\n        resume(key, arg);\n      }\n    });\n  }\n\n  function resume(key, arg) {\n    try {\n      var result = gen[key](arg);\n      var value = result.value;\n      var wrappedAwait = value instanceof _AwaitValue;\n      Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {\n        if (wrappedAwait) {\n          resume(\"next\", arg);\n          return;\n        }\n\n        settle(result.done ? \"return\" : \"normal\", arg);\n      }, function (err) {\n        resume(\"throw\", err);\n      });\n    } catch (err) {\n      settle(\"throw\", err);\n    }\n  }\n\n  function settle(type, value) {\n    switch (type) {\n      case \"return\":\n        front.resolve({\n          value: value,\n          done: true\n        });\n        break;\n\n      case \"throw\":\n        front.reject(value);\n        break;\n\n      default:\n        front.resolve({\n          value: value,\n          done: false\n        });\n        break;\n    }\n\n    front = front.next;\n\n    if (front) {\n      resume(front.key, front.arg);\n    } else {\n      back = null;\n    }\n  }\n\n  this._invoke = send;\n\n  if (typeof gen.return !== \"function\") {\n    this.return = undefined;\n  }\n}\n\nif (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n  _AsyncGenerator.prototype[Symbol.asyncIterator] = function () {\n    return this;\n  };\n}\n\n_AsyncGenerator.prototype.next = function (arg) {\n  return this._invoke(\"next\", arg);\n};\n\n_AsyncGenerator.prototype.throw = function (arg) {\n  return this._invoke(\"throw\", arg);\n};\n\n_AsyncGenerator.prototype.return = function (arg) {\n  return this._invoke(\"return\", arg);\n};\n\nfunction _wrapAsyncGenerator(fn) {\n  return function () {\n    return new _AsyncGenerator(fn.apply(this, arguments));\n  };\n}\n\nfunction _awaitAsyncGenerator(value) {\n  return new _AwaitValue(value);\n}\n\nfunction _asyncGeneratorDelegate(inner, awaitWrap) {\n  var iter = {},\n      waiting = false;\n\n  function pump(key, value) {\n    waiting = true;\n    value = new Promise(function (resolve) {\n      resolve(inner[key](value));\n    });\n    return {\n      done: false,\n      value: awaitWrap(value)\n    };\n  }\n\n  ;\n\n  if (typeof Symbol === \"function\" && Symbol.iterator) {\n    iter[Symbol.iterator] = function () {\n      return this;\n    };\n  }\n\n  iter.next = function (value) {\n    if (waiting) {\n      waiting = false;\n      return value;\n    }\n\n    return pump(\"next\", value);\n  };\n\n  if (typeof inner.throw === \"function\") {\n    iter.throw = function (value) {\n      if (waiting) {\n        waiting = false;\n        throw value;\n      }\n\n      return pump(\"throw\", value);\n    };\n  }\n\n  if (typeof inner.return === \"function\") {\n    iter.return = function (value) {\n      return pump(\"return\", value);\n    };\n  }\n\n  return iter;\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function step(key, arg) {\n        try {\n          var info = gen[key](arg);\n          var value = info.value;\n        } catch (error) {\n          reject(error);\n          return;\n        }\n\n        if (info.done) {\n          resolve(value);\n        } else {\n          Promise.resolve(value).then(_next, _throw);\n        }\n      }\n\n      function _next(value) {\n        step(\"next\", value);\n      }\n\n      function _throw(err) {\n        step(\"throw\", err);\n      }\n\n      _next();\n    });\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineEnumerableProperties(obj, descs) {\n  for (var key in descs) {\n    var desc = descs[key];\n    desc.configurable = desc.enumerable = true;\n    if (\"value\" in desc) desc.writable = true;\n    Object.defineProperty(obj, key, desc);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    var objectSymbols = Object.getOwnPropertySymbols(descs);\n\n    for (var i = 0; i < objectSymbols.length; i++) {\n      var sym = objectSymbols[i];\n      var desc = descs[sym];\n      desc.configurable = desc.enumerable = true;\n      if (\"value\" in desc) desc.writable = true;\n      Object.defineProperty(obj, sym, desc);\n    }\n  }\n\n  return obj;\n}\n\nfunction _defaults(obj, defaults) {\n  var keys = Object.getOwnPropertyNames(defaults);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = Object.getOwnPropertyDescriptor(defaults, key);\n\n    if (value && value.configurable && obj[key] === undefined) {\n      Object.defineProperty(obj, key, value);\n    }\n  }\n\n  return obj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return _get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar _gPO = Object.getPrototypeOf || function _gPO(o) {\n  return o.__proto__;\n};\n\nvar _sPO = Object.setPrototypeOf || function _sPO(o, p) {\n  o.__proto__ = p;\n  return o;\n};\n\nvar _construct = typeof Reflect === \"object\" && Reflect.construct || function _construct(Parent, args, Class) {\n  var Constructor,\n      a = [null];\n  a.push.apply(a, args);\n  Constructor = Parent.bind.apply(Parent, a);\n  return _sPO(new Constructor(), Class.prototype);\n};\n\nvar _cache = typeof Map === \"function\" && new Map();\n\nfunction _wrapNativeSuper(Class) {\n  if (typeof Class !== \"function\") {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  if (typeof _cache !== \"undefined\") {\n    if (_cache.has(Class)) return _cache.get(Class);\n\n    _cache.set(Class, Wrapper);\n  }\n\n  function Wrapper() {}\n\n  Wrapper.prototype = Object.create(Class.prototype, {\n    constructor: {\n      value: Wrapper,\n      enumerable: false,\n      writeable: true,\n      configurable: true\n    }\n  });\n  return _sPO(Wrapper, _sPO(function Super() {\n    return _construct(Class, arguments, _gPO(this).constructor);\n  }, Class));\n}\n\nfunction _instanceof(left, right) {\n  if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n    return right[Symbol.hasInstance](left);\n  } else {\n    return left instanceof right;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _newArrowCheck(innerThis, boundThis) {\n  if (innerThis !== boundThis) {\n    throw new TypeError(\"Cannot instantiate an arrow function\");\n  }\n}\n\nfunction _objectDestructuringEmpty(obj) {\n  if (obj == null) throw new TypeError(\"Cannot destructure undefined\");\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _set(object, property, value, receiver) {\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent !== null) {\n      _set(parent, property, value, receiver);\n    }\n  } else if (\"value\" in desc && desc.writable) {\n    desc.value = value;\n  } else {\n    var setter = desc.set;\n\n    if (setter !== undefined) {\n      setter.call(receiver, value);\n    }\n  }\n\n  return value;\n}\n\nfunction _sliceIterator(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _slicedToArray(arr, i) {\n  if (Array.isArray(arr)) {\n    return arr;\n  } else if (Symbol.iterator in Object(arr)) {\n    return _sliceIterator(arr, i);\n  } else {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n  }\n}\n\nfunction _slicedToArrayLoose(arr, i) {\n  if (Array.isArray(arr)) {\n    return arr;\n  } else if (Symbol.iterator in Object(arr)) {\n    var _arr = [];\n\n    for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {\n      _arr.push(_step.value);\n\n      if (i && _arr.length === i) break;\n    }\n\n    return _arr;\n  } else {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n  }\n}\n\nfunction _taggedTemplateLiteral(strings, raw) {\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}\n\nfunction _taggedTemplateLiteralLoose(strings, raw) {\n  strings.raw = raw;\n  return strings;\n}\n\nfunction _temporalRef(val, name) {\n  if (val === _temporalUndefined) {\n    throw new ReferenceError(name + \" is not defined - temporal dead zone\");\n  } else {\n    return val;\n  }\n}\n\nfunction _readOnlyError(name) {\n  throw new Error(\"\\\"\" + name + \"\\\" is read-only\");\n}\n\nfunction _classNameTDZError(name) {\n  throw new Error(\"Class \\\"\" + name + \"\\\" cannot be referenced in computed property keys.\");\n}\n\nvar _temporalUndefined = {};\n\nfunction _toArray(arr) {\n  return Array.isArray(arr) ? arr : Array.from(arr);\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _skipFirstGeneratorNext(fn) {\n  return function () {\n    var it = fn.apply(this, arguments);\n    it.next();\n    return it;\n  };\n}\n\nfunction _toPropertyKey(key) {\n  if (typeof key === \"symbol\") {\n    return key;\n  } else {\n    return String(key);\n  }\n}\n\nfunction _initializerWarningHelper(descriptor, context) {\n  throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and set to use loose mode. ' + 'To use proposal-class-properties in spec mode with decorators, wait for ' + 'the next major version of decorators in stage 2.');\n}\n\nfunction _initializerDefineProperty(target, property, descriptor, context) {\n  if (!descriptor) return;\n  Object.defineProperty(target, property, {\n    enumerable: descriptor.enumerable,\n    configurable: descriptor.configurable,\n    writable: descriptor.writable,\n    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0\n  });\n}\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n\n  if (desc.initializer === void 0) {\n    Object['define' + 'Property'](target, property, desc);\n    desc = null;\n  }\n\n  return desc;\n}"],"names":["options","undefined","isSpeedy","speedy","maxLength","this","tags","ctr","nonce","key","container","document","head","rule","tag","createElement","setAttribute","appendChild","createTextNode","push","length","sheet","i","styleSheets","ownerNode","sheetForTag","insertRule","cssRules","e","parentNode","removeChild","forEach","StyleSheet","insert","flush","shouldSerializeToReactTree","isBrowser","process","fn","cache","hyphenateRegex","processStyleName","styleName","replace","toLowerCase","arg","processStyleValue","value","unitless","charCodeAt","isNaN","handleInterpolation","registered","interpolation","toString","call","type","name","styles","obj","string","Array","isArray","keys","cached","labelPattern","serializeStyles","args","identifierName","str","k","l","h","hashString","match","p1","consume","renderChild","Global","subClass","superClass","context","serialized","_this","props","css","oldName","rules","stylis","join","React.createElement","prototype","Object","create","constructor","__proto__","componentWillUnmount","render","React","__emotion_component"],"mappings":"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"}